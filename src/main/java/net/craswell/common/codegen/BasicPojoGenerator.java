package net.craswell.common.codegen;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import javax.annotation.Generated;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementFilter;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

/**
 * Generates basic POJO classes from template classes with only fields. Annotations and modifiers
 * are preserved.
 * 
 * @author scraswell@gmail.com
 *
 */
public class BasicPojoGenerator
    extends SourceGeneratorAbstract {
  /**
   * The suffix to be appended to the template class.
   */
  private static final String SUFFIX = "Pojo";

  /**
   * Constructs a basic POJO source file from a template class.
   * 
   * @param packageName The package name to be attributed with the source file.
   * @param templateClass The template class from which the POJO would be derived.
   * 
   * @return The source Java File for the newly generated class.
   */
  public JavaFile constructPojoSourceFileFromTypeElement(
      String packageName,
      TypeElement typeElement) {

    TypeSpec typeSpec = this.constructTypeSpecFromTemplateClass(typeElement);

    return JavaFile
        .builder(packageName, typeSpec)
        .addFileComment("This code was generated by a tool.")
        .build();
  }

  /**
   * Generates a basic POJO class from a template class containing only fields.
   * 
   * @param templateClass The template class.
   * 
   * @return The basic POJO class.
   */
  public TypeSpec constructTypeSpecFromTemplateClass(TypeElement typeElement) {
    if (typeElement == null) {
      throw new IllegalArgumentException("typeElement");
    }

    String templateClassName = typeElement
        .getSimpleName()
        .toString();

    TypeSpec.Builder typeSpecBuilder = this.constructTypeSpecBuilder(
        templateClassName,
        this.constructClassAnnotations(typeElement));

    this.declareSuperclass(
        typeElement,
        typeSpecBuilder);

    this.declareInterfaces(
        typeElement,
        typeSpecBuilder);

    typeSpecBuilder.addModifiers(
        typeElement.getModifiers().toArray(new Modifier[typeElement.getModifiers().size()]));

    this.processTemplateClassFields(
        typeElement,
        typeSpecBuilder);

    return typeSpecBuilder
        .build();
  }

  /**
   * Constructs the class annotations.
   * 
   * @param typeElement The type element.
   * 
   * @return The class annotations.
   */
  protected List<AnnotationSpec> constructClassAnnotations(TypeElement typeElement) {
    List<AnnotationSpec> annotationSpecs = new ArrayList<AnnotationSpec>();

    annotationSpecs.add(AnnotationSpec
        .builder(Generated.class)
        .addMember("value", "\"$L\"", this.getClass().getCanonicalName())
        .build());

    List<AnnotationMirror> annotationMirrors = typeElement
        .getAnnotationMirrors()
        .stream()
        .filter(this.getAnnotationFilter())
        .collect(Collectors.toList());

    for(AnnotationMirror annotationMirror : annotationMirrors) {
      annotationSpecs.add(AnnotationSpec.get(annotationMirror));
    }

    return annotationSpecs;
  }

  /**
   * Declares the interfaces implemented by the template class.
   * 
   * @param templateClass The template class.
   * @param typeSpecBuilder The type spec builder.
   */
  protected void declareInterfaces(
      TypeElement typeElement,
      TypeSpec.Builder typeSpecBuilder) {
    for (TypeMirror typeMirror : typeElement.getInterfaces()) {
      typeSpecBuilder.addSuperinterface(TypeName.get(typeMirror));
    }
  }

  /**
   * Declares the class from which the template class is derived.
   * 
   * @param typeElement The template class.
   * @param typeSpecBuilder The type spec builder.
   */
  protected void declareSuperclass(
      TypeElement typeElement,
      TypeSpec.Builder typeSpecBuilder) {

    if (typeElement != null) {
      typeSpecBuilder.superclass(TypeName.get(typeElement.getSuperclass()));
    }
  }

  /**
   * Constructs the type specification builder.
   * 
   * @param templateClass
   * @param generatedClassName
   * @return The type specification builder.
   */
  protected TypeSpec.Builder constructTypeSpecBuilder(
      String templateClassName,
      Iterable<AnnotationSpec> annotationSpecs) {
    String generatedClassName = this.constructGeneratedClassName(templateClassName);

    return TypeSpec
        .classBuilder(generatedClassName)
        .addJavadoc(this.constructClassJavadoc(generatedClassName))
        .addAnnotations(annotationSpecs);
  }

  /**
   * Gets the suffix to append to specific generated members.
   * @return The suffix to be appended to specific generated members.
   */
  protected String getSuffix() {
    return SUFFIX;
  }

  /**
   * Constructs the class Javadoc.
   * 
   * @param generatedClassName The generated class name.
   * @return The generated class javadoc.
   */
  protected CodeBlock constructClassJavadoc(String generatedClassName) {
    return CodeBlock
        .builder()
        .add("Generated class => $L\n", generatedClassName)
        .build();
  }

  /**
   * Processes all fields from the template class.
   * 
   * @param templateClass The template class.
   * @param typeSpecBuilder The type spec builder.
   */
  protected void processTemplateClassFields(
      TypeElement typeElement,
      TypeSpec.Builder typeSpecBuilder) {

    for (VariableElement field : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {
      this.processField(typeSpecBuilder, field);
    }
  }

  /**
   * Creates a copy of the field and generates associated getters and setters.
   * 
   * @param typeSpecBuilder The type spec builder.
   * @param field The field.
   */
  protected void processField(
      TypeSpec.Builder typeSpecBuilder,
      VariableElement field) {

    String fieldName = field.getSimpleName().toString();
    TypeName fieldType = TypeName.get(field.asType());

    typeSpecBuilder
        .addField(this.copyField(field))
        .addMethod(this.constructBasicGetterSpecForFieldName(fieldName, fieldType))
        .addMethod(this.constructBasicSetterSpecForFieldName(fieldName, fieldType));
  }

  /**
   * Creates a copy of the field.
   * 
   * @param field The field.
   * 
   * @return The field specification.
   */
  protected FieldSpec copyField(VariableElement field) {
    return this.constructField(
        field.getSimpleName().toString(),
        TypeName.get(field.asType()),
        field.getModifiers().toArray(new Modifier[field.getModifiers().size()]),
        this.copyAnnotations(field));
  }

  /**
   * Constructs the generated class name.
   * 
   * @param templateClassName The template class name.
   * 
   * @return The generated class name.
   */
  protected String constructGeneratedClassName(String templateClassName) {
    return String.format(
        "%1$s%2$s",
        templateClassName,
        this.getSuffix());
  }
}
